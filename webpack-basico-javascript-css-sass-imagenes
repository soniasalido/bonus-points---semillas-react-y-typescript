COMANDOS PARA ARRANCAR WEBPACK

(0)
mkdir nombreProyecto
cd nombreProyecto

(1)
npm init -y
npm install webpack webpack-cli  --save-dev
npm install @babel/cli @babel/core @babel/preset-env  --save-dev
npm install babel-loader --save-dev
npm install webpack-dev-server --save-dev
npm install html-webpack-plugin --save-dev



(2)
// Creamos carpeta src.
// Creamos dentro de src un index.js  -> console.log("hola mundo");
mkdir src
cd src
nano index.js ------> console.log('Hola mundo');



(3)
cd ..
nano .gitignore  ------>
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and *not* Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port





(4)
// Creamos ficjero webpack.config.js
nano webpack.config.js  ------>

const htmlWebPackPlugin = require("html-webpack-plugin");

module.exports = {
  // Se establece la opción 'modo' en 'desarrollo' para habilitar los
  // valores predeterminados para cada entorno. Falla si no se pone
  mode: 'development',
  entry: ["./src/index.js"],

  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: "babel-loader",
      },
    ],
  },
  plugins: [
    // Instanciamos el htmlWebPackPlugin
    new htmlWebPackPlugin({
      filename: 'index.html',
      template: './src/index.html',
      scriptLoading: 'blocking',
      hash: true,
    })
  ],
  devServer: {
    compress: true,
    port: 9000,
  },
};





(5)
// Creamos fichero .babelrc
nano .babelrc  ------>
{
  "presets": [
    "@babel/preset-env"
  ]
}



(6)
// Creamos un index.html dentro de src y agregamos un script
cd src
nano index.html  ------>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <div class="red-background">fodo rojo</div>
</body>
</html>





(7)
// Modificamos fichero package.json:
  "scripts": {
    "build": "webpack --mode development",
    "start": "webpack-dev-server --mode development",
    "test": "echo \"Error: no test specified\" && exit 1"
  },



(8)
// Ejecutamos run build para que genere la carpeta dist y dentro main.js que hace el bundler con todo
npm run build




(9)
npm start


-------------------------------------------------------------------------------------------------------------
(1)AÑADIR CSS
// Incluimos css en webpack para que sepa manejar los ficheros css:
npm install style-loader css-loader --save-dev



(2)
// Creamos un fichero en directorio src mystyles.css
.red-background {
	background-color: indianred;
}



(3)
// Importamos el ficher css en index.js
import "./mystyles.css";


(4)
// Para que se borre la carpeta dist de forma automática modificamos webpack.config.js
  output: {
    filename: "[name].[chunkhash].js",
    clean: true,
  },




(4)
// Fichero completo de webpack.config.js:
const htmlWebPackPlugin = require("html-webpack-plugin");

module.exports = {
  // Se establece la opción 'modo' en 'desarrollo' para habilitar los valores predeterminados para cada entorno.
  mode: 'development',
  // Cambiamos los puntos de entrada tratándolo en vez de como un array, como un objeto con su par: clave-valor
  // Defino un punto de entrada para la aplicación --> app
  // Defino un punto de entrada para el css --> appStyles
  entry: {
    app: "./src/index.js",
    appStyles: "./src/mystyles.css"
  },
  // Definimos las Salidas que va a generar webpack.
  // Al hacer chunkhash genera un hash relacionado con el contenido del fichero, así tendremos un nombre único
  output: {
    filename: "[name].[chunkhash].js",
    clean: true,
  },

  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: "babel-loader",
      },
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader"],
        exclude: /node_modules/,
      }
    ],
  },
  plugins: [
    // Instanciamos el htmlWebPackPlugin
    new htmlWebPackPlugin({
      filename: 'index.html',
      template: './src/index.html',
      scriptLoading: 'blocking',
      hash: true,
    })
  ],
  devServer: {
    compress: true,
    port: 9000,
  },
};




(6)
// Abstraemos el css: Sacamos fuera el css  --> Instalamos el plugin mini-css-extract-plugin
// Modificamos webpack.config.js para incluirlo
npm install mini-css-extract-plugin --save-dev




(7)
// Modificamos webpack.config.js para que pueda manejar el plugin mini-css-extract-plugin
const htmlWebPackPlugin = require("html-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");


module.exports = {
  // Se establece la opción 'modo' en 'desarrollo' para habilitar los valores predeterminados para cada entorno.
  mode: 'development',
  // Cambiamos los puntos de entrada tratándolo en vez de como un array, como un objeto con su par: clave-valor
  // Defino un punto de entrada para la aplicación --> app
  // Defino un punto de entrada para el css --> appStyles
  entry: {
    app: "./src/index.js",
    appStyles: "./src/mystyles.css"
  },
  // Definimos las Salidas que va a generar webpack.
  // Al hacer chunkhash genera un hash relacionado con el contenido del fichero, así tendremos un nombre único
  output: {
    filename: "[name].[chunkhash].js",
    clean: true,
  },

  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: "babel-loader",
      },
      {
        test: /\.css$/,
        // Usamos el plugin: mini-css-extract-plugin para tener un ficher externo de css.
        // Previamente hay que instalarlo con npm install
        use: [MiniCssExtractPlugin.loader, "css-loader"],
      }
    ],
  },
  plugins: [
    // Instanciamos el htmlWebPackPlugin
    new htmlWebPackPlugin({
      filename: 'index.html',
      template: './src/index.html',
      scriptLoading: 'blocking',
    }),
    new MiniCssExtractPlugin({
      filename: '[name].[chunkhash].css',
    })
  ],
  devServer: {
    compress: true,
    port: 9000,
  },
};



-----------------------------------------------------------------------------------------------------------------------
(1)AÑADIR SASS
// Añadimos sass
// Eliminamos fichero css o sustituimos la extensión por scss
// creamos un fichero: mystyles.scss y añadimos algo de sass a ese fichero  --->
$primary-color: #1b29c4;
$secudary-color: #efd006;

.red-background{
  background-color: $primary-color;
}

body {
  font-family: $font-stack;
  color: $secudary-color;
}



(2)
// Importamos el fichero scss en index.js
import "./mystyles.scss";


(2)
// Instalamos el paquete sass y un loader de sass:
npm install sass sass-loader --save-dev


(3)
// Modificamos webpack.config.js
    entry: {
        app: "./src/index.js",
        appStyles: "./src/mystyles.scss"
    },
    
    
    
    
(4)
// Modificamos webpack.config.js
            {
                test: /\.scss$/,
                exclude: /node_modules/,
                use: [
                    MiniCssExtractPlugin.loader,
                    "css-loader",
                    {
                        loader: "sass-loader",
                        options: {
                            implementation: require("sass"),
                        },
                    },
                ],
            },


(5)
// Webpack.config.js completo:
const htmlWebPackPlugin = require("html-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");


module.exports = {
    // Se establece la opción 'modo' en 'desarrollo' para habilitar los valores predeterminados para cada entorno.
    mode: 'development',
    // Cambiamos los puntos de entrada tratándolo en vez de como un array, como un objeto con su par: clave-valor
    // Defino un punto de entrada para la aplicación --> app
    // Defino un punto de entrada para el css --> appStyles
    entry: {
        app: "./src/index.js",
        appStyles: "./src/mystyles.scss"
    },
    // Definimos las Salidas que va a generar webpack.
    // Al hacer chunkhash genera un hash relacionado con el contenido del fichero, así tendremos un nombre único
    output: {
        filename: "[name].[chunkhash].js",
        clean: true,
    },

    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                loader: "babel-loader",
            },
            {
                test: /\.scss$/,
                exclude: /node_modules/,
                use: [
                    MiniCssExtractPlugin.loader,
                    "css-loader",
                    {
                        loader: "sass-loader",
                        options: {
                            implementation: require("sass"),
                        },
                    },
                ],
            },
            {
                test: /\.css$/,
                // Usamos el plugin: mini-css-extract-plugin para tener un ficher externo de css.
                // Previamente hay que instalarlo con npm install
                use: [MiniCssExtractPlugin.loader, "css-loader"],
            }
        ],
    },
    plugins: [
        // Instanciamos el htmlWebPackPlugin
        new htmlWebPackPlugin({
            filename: 'index.html',
            template: './src/index.html',
            scriptLoading: 'blocking',
        }),
        new MiniCssExtractPlugin({
            filename: '[name].[chunkhash].css',
        })
    ],
    devServer: {
        compress: true,
        port: 9000,
    },
};

--------------------------------------------------------------------------------------------------------
(1) AÑADIR FOTO
// Creamos dentro de src una carpeta llamada content
// Incluimos una imagen en content
// importamos la foto en index.js
import nombreFoto from "./content/nombreFoto.jpg";


(2)
// Instalamos el loader: html-loader
npm install html-loader --save-dev


(3)
// Ahora no hace falta importamos unloader para manejar la foto
// modificamos webpack.config.js:
{
	test: /\.(png|jpg|gif)$/,
	type: "asset/resource",
}
            

(4)
//Incorporamos la foto al index.js
const img = document.createElement("img");
img.src= nombreFoto;
document.getElementById("imgContainer").appendChild(img);



(5)
// En index.html creamos un div id imgContainer donde se mostratá la foto
<div id="imgContainer"></div>



(6)
// modificamos webpack.config.js

const path = require("path");

.
.
.
{
	test: /\.html$/,
	loader: "html-loader",
}
.
.
.
devServer: {
	compress: true,
	port: 9000,
	static:{
	    directory: path.join(__dirname, 'src'),
	}
},


(7)
const htmlWebPackPlugin = require("html-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const path = require("path");
const basePath = __dirname;

module.exports = {
    // Se establece la opción 'modo' en 'desarrollo' para habilitar los valores predeterminados para cada entorno.
    mode: 'development',
    context: path.join(basePath, "src"),
    resolve: {
        extensions: [".js", ".jsx", ".tsx", "ts"]
    },
    // Cambiamos los puntos de entrada tratándolo en vez de como un array, como un objeto con su par: clave-valor
    // Defino un punto de entrada para la aplicación --> app
    // Defino un punto de entrada para el css --> appStyles
    entry: {
        app: "./index.tsx",
        appStyles: "./mystyles.scss"
    },
    // Definimos las Salidas que va a generar webpack.
    // Al hacer chunkhash genera un hash relacionado con el contenido del fichero, así tendremos un nombre único
    output: {
        filename: "[name].[chunkhash].js",
        clean: true,
    },

    module: {
        rules: [
            {
                test: /\.(tsx|jsx)$/,
                exclude: /node_modules/,
                loader: "babel-loader",
            },
            {
                test: /\.scss$/,
                exclude: /node_modules/,
                use: [
                    MiniCssExtractPlugin.loader,
                    "css-loader",
                    {
                        loader: "sass-loader",
                        options: {
                            implementation: require("sass"),
                        },
                    },
                ],
            },
            {
                test: /\.css$/,
                // Usamos el plugin: mini-css-extract-plugin para tener un ficher externo de css.
                // Previamente hay que instalarlo con npm install
                use: [MiniCssExtractPlugin.loader, "css-loader"],
            },
            {
                test: /\.(png|jpg|gif)$/,
                type: "asset/resource",
            },
            {
                test: /\.html$/,
                loader: "html-loader",
            }
        ],
    },
    plugins: [
        // Instanciamos el htmlWebPackPlugin
        new htmlWebPackPlugin({
            filename: 'index.html',
            template: './index.html',
            scriptLoading: 'blocking',
        }),
        new MiniCssExtractPlugin({
            filename: '[name].[chunkhash].css',
        })
    ],
    devServer: {
        compress: true,
        port: 9000,
        static:{
            directory: path.join(__dirname, 'src'),
        }
    },
};



----------------------------------------
//HAY QUE MONTAR UN POLLO PARA QUE FUNCIONE LA IMPORTACIÓN DE LA FOTO SIN QUE DE UN ERROR
// HAY QUE CREAR UN FICHERO: src/types/images.d.ts
// DENTRO DEL FICHERO PONER:
declare module '*.jpg';
declare module '*.jpeg';

// AGREGAR EN tsconfig.json:
"typeRoots" : ["node_modules/@types", "src/types"]

// YA CON ESTO NO DA ERROR AL RENOMBRAR index.jsx A index.tsx


